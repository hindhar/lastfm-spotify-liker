Directory Structure:
====================

lastfm-spotify-liker/
    .DS_Store
    requirements.txt
    codebase.py
    README.md
    codebase.txt
    .gitignore
    .env
    album_saver.db
    .cache
    playlist_id.txt
    logs/
        album_saver.log
        hot_100_playlist.log
        .gitignore
        lastfm_spotify_liker.log
    db/
        spotify_liked_songs.db
        lastfm_100_days.db
        .gitignore
    .vscode/
        settings.json
    src/
        .DS_Store
        database.py
        __init__.py
        utils.py
        spotify_operations.py
        scripts/
            album_saver.py
            spotify_deduplicator.py
            .DS_Store
            __init__.py
            lastfm_spotify_liker.py
            remove_duplicate_albums.py
            hot_100_playlist.py


File Contents:
==============

File: requirements.txt
======================

certifi==2024.8.30
charset-normalizer==3.4.0
fuzzywuzzy==0.18.0
idna==3.10
Levenshtein==0.26.0
python-dotenv==1.0.1
python-Levenshtein==0.26.0
RapidFuzz==3.10.0
redis==5.1.1
requests==2.32.3
spotipy==2.24.0
urllib3==2.2.3


File: README.md
===============



File: album_saver.db
====================

Error reading file: 'utf-8' codec can't decode byte 0xd7 in position 27: invalid continuation byte


File: playlist_id.txt
=====================

5iFg7DdS2m8XV8kmQqg4SU

File: db/spotify_liked_songs.db
===============================

Error reading file: 'utf-8' codec can't decode byte 0xe6 in position 31: invalid continuation byte


File: db/lastfm_100_days.db
===========================

Error reading file: 'utf-8' codec can't decode byte 0xd0 in position 99: invalid continuation byte


File: src/database.py
=====================

# database.py

import sqlite3
import logging
from datetime import datetime, timezone
from .utils import normalize_string

class Database:
    def __init__(self, db_file='db/lastfm_history.db'):
        self.db_file = db_file
        self.create_table()

    def connect(self):
        return sqlite3.connect(self.db_file)

    def create_table(self):
        with self.connect() as conn:
            c = conn.cursor()
            c.execute('''
                CREATE TABLE IF NOT EXISTS tracks (
                    id INTEGER PRIMARY KEY,
                    artist TEXT,
                    name TEXT,
                    album TEXT,
                    listen_count INTEGER,
                    last_listened DATETIME,
                    mbid TEXT,
                    UNIQUE(artist, name)
                )
            ''')
        self.add_processed_column()

    def add_or_update_track(self, track):
        artist = normalize_string(track['artist'])
        name = normalize_string(track['name'])
        album = normalize_string(track.get('album', ''))
        date = track['date'].astimezone(timezone.utc).isoformat()
        query = '''
        INSERT INTO tracks (artist, name, album, listen_count, last_listened, mbid)
        VALUES (?, ?, ?, 1, ?, ?)
        ON CONFLICT(artist, name) DO UPDATE SET
        listen_count = listen_count + 1,
        last_listened = ?,
        album = COALESCE(?, album),
        mbid = COALESCE(?, mbid)
        '''
        with self.connect() as conn:
            conn.execute(query, (
                artist,
                name,
                album,
                date,
                track.get('mbid', ''),
                date,
                album,
                track.get('mbid', '')
            ))

    def get_last_update_time(self):
        query = 'SELECT MAX(last_listened) FROM tracks'
        with self.connect() as conn:
            result = conn.execute(query).fetchone()
        if result and result[0]:
            # Ensure the returned datetime is timezone-aware and in UTC
            return datetime.fromisoformat(result[0]).replace(tzinfo=timezone.utc)
        return None

    def get_frequently_played_tracks(self, min_count=5):
        query = '''
        SELECT artist, name, listen_count
        FROM tracks
        WHERE listen_count >= ? AND processed = 0
        ORDER BY listen_count DESC
        '''
        with self.connect() as conn:
            return conn.execute(query, (min_count,)).fetchall()

    def mark_tracks_as_processed(self, tracks):
        with self.connect() as conn:
            c = conn.cursor()
            for artist, name, _ in tracks:
                c.execute('''
                    UPDATE tracks
                    SET processed = 1
                    WHERE artist = ? AND name = ?
                ''', (artist, name))
            conn.commit()

    def add_processed_column(self):
        with self.connect() as conn:
            c = conn.cursor()
            try:
                c.execute('ALTER TABLE tracks ADD COLUMN processed BOOLEAN DEFAULT 0')
                conn.commit()
                logging.info("Added 'processed' column to tracks table")
            except sqlite3.OperationalError as e:
                if "duplicate column name" in str(e):
                    logging.info("'processed' column already exists in tracks table")
                else:
                    raise


File: src/__init__.py
=====================



File: src/utils.py
==================

# utils.py
import re

def normalize_string(s):
    s = s.lower().strip()
    # Remove content in parentheses or brackets
    s = re.sub(r'\s*[\(\[\{].*?[\)\]\}]', '', s)
    # Remove version-specific keywords and their accompanying years if any
    s = re.sub(r'\b(remastered|live|acoustic|mono|stereo|version|edit|feat\.?|featuring|from|remix)\b(\s+\d{4})?', '', s)
    # Remove extra punctuation (but keep numbers)
    s = re.sub(r'[^a-zA-Z0-9\s]', '', s)
    # Remove extra whitespace
    s = re.sub(r'\s+', ' ', s)
    return s.strip()


File: src/spotify_operations.py
===============================

# spotify_operations.py

import os
import sys
import re
import logging
import time
from datetime import datetime, timezone
import sqlite3
from dotenv import load_dotenv
import spotipy
from spotipy.oauth2 import SpotifyOAuth
from rapidfuzz import fuzz, process
from src.utils import normalize_string
from src.database import Database

# Load environment variables
load_dotenv()

# Use environment variable for database file path
SPOTIFY_DB_FILE = os.getenv('SPOTIFY_DB_FILE', 'db/spotify_liked_songs.db')
LASTFM_DB_FILE = os.getenv('LASTFM_DB_FILE', 'db/lastfm_history.db')

class SpotifyOperations:
    """Handles operations related to Spotify, including searching and liking tracks."""

    def __init__(self, db_file=SPOTIFY_DB_FILE):
        """Initialize the Spotify operations and create necessary database tables."""
        self.sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope="user-library-read user-library-modify"))
        self.db_file = db_file
        self.create_table()

    def create_table(self):
        """Create necessary tables in the database if they don't exist."""
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        
        # Create the liked_songs table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS liked_songs
                     (id TEXT PRIMARY KEY, name TEXT, artist TEXT, album TEXT, album_id TEXT, added_at TEXT)''')
        
        # Create metadata table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS metadata
                     (key TEXT PRIMARY KEY, value TEXT)''')
        
        # Create search_cache table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS search_cache
                     (name TEXT, artist TEXT, track_id TEXT, PRIMARY KEY (name, artist))''')
        
        # Create unfound_tracks table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS unfound_tracks
                     (artist TEXT, name TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                      PRIMARY KEY (artist, name))''')
        
        conn.commit()
        conn.close()

    def fetch_all_liked_songs(self):
        offset = 0
        limit = 50
        all_tracks = []

        while True:
            results = self.sp.current_user_saved_tracks(limit=limit, offset=offset)
            tracks = results['items']
            if len(tracks) == 0:
                break
            all_tracks.extend(tracks)
            offset += limit

        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()

        for item in all_tracks:
            track = item['track']
            name = normalize_string(track['name'])
            artist = normalize_string(track['artists'][0]['name'])
            album = normalize_string(track['album']['name'])
            album_id = track['album']['id']
            c.execute("INSERT OR REPLACE INTO liked_songs VALUES (?, ?, ?, ?, ?, ?)",
                      (track['id'], name, artist, album, album_id, item['added_at']))

        conn.commit()
        conn.close()

        return len(all_tracks)

    def get_liked_songs_set(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT name, artist FROM liked_songs")
        liked_songs = c.fetchall()
        conn.close()
        
        # Check for duplicates
        liked_set = set()
        duplicates = set()
        for name, artist in liked_songs:
            if (name, artist) in liked_set:
                duplicates.add((name, artist))
            else:
                liked_set.add((name, artist))
        
        logging.info(f"Retrieved {len(liked_set)} unique liked songs from local database")
        if duplicates:
            logging.warning(f"Found {len(duplicates)} duplicate entries in liked_songs table")
            for name, artist in list(duplicates)[:5]:  # Log first 5 duplicates
                logging.warning(f"Duplicate: {artist} - {name}")
        
        return liked_set

    def remove_duplicates(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("""
            DELETE FROM liked_songs
            WHERE rowid NOT IN (
                SELECT MIN(rowid)
                FROM liked_songs
                GROUP BY name, artist
            )
        """)
        removed = c.rowcount
        conn.commit()
        conn.close()
        logging.info(f"Removed {removed} duplicate entries from liked_songs table")

    def like_tracks(self, track_ids):
        batch_size = 50  # Spotify allows up to 50 tracks to be liked at once
        for i in range(0, len(track_ids), batch_size):
            batch = track_ids[i:i+batch_size]
            try:
                self.sp.current_user_saved_tracks_add(tracks=batch)
                logging.info(f"Liked {len(batch)} tracks")
                # After liking tracks, add them to the local database
                self._save_newly_liked_tracks(batch)
                logging.info(f"Saved {len(batch)} newly liked tracks to local database")
            except spotipy.exceptions.SpotifyException as e:
                logging.error(f"Error liking tracks: {e}")
                time.sleep(2)  # Wait before retrying
            time.sleep(0.1)  # Add a small delay to avoid rate limiting

    def _save_newly_liked_tracks(self, track_ids):
        # Fetch details of the newly liked tracks in batches
        batch_size = 50
        tracks = []
        for i in range(0, len(track_ids), batch_size):
            batch = track_ids[i:i+batch_size]
            response = self.sp.tracks(batch)
            for track in response['tracks']:
                tracks.append({
                    'added_at': datetime.utcnow().replace(tzinfo=timezone.utc).isoformat(),
                    'track': track
                })
            time.sleep(0.1)  # To respect rate limits

        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        for item in tracks:
            track = item['track']
            name = normalize_string(track['name'])
            artist = normalize_string(track['artists'][0]['name'])
            album = normalize_string(track['album']['name'])
            album_id = track['album']['id']
            
            # Check if the track already exists
            c.execute("SELECT id FROM liked_songs WHERE name = ? AND artist = ?", (name, artist))
            existing = c.fetchone()
            if existing:
                logging.info(f"Track already in database: {artist} - {name}")
            else:
                c.execute("INSERT INTO liked_songs VALUES (?, ?, ?, ?, ?, ?)",
                          (track['id'], name, artist, album, album_id, item['added_at']))
                logging.info(f"Saving newly liked track: {artist} - {name}")
        
        conn.commit()
        conn.close()

    def search_track(self, name, artist):
        """Search for a track on Spotify and return its ID if found."""
        # Check cache first
        cached_id = self.get_cached_track_id(name, artist)
        if cached_id is not None:
            return cached_id

        # Define query variations
        queries = [
            f"track:{name} artist:{artist}",
            f"track:{name}",
            f"{name} {artist}"
        ]

        for query in queries:
            track_id = self._search_and_match(query, name, artist)
            if track_id:
                self.cache_track_id(name, artist, track_id)
                return track_id

        # Cache negative result
        self.cache_track_id(name, artist, None)
        return None

    def _search_and_match(self, query, name, artist):
        """Perform a search query and match results against the given name and artist."""
        try:
            results = self.sp.search(q=query, type='track', limit=10)
            if results['tracks']['items']:
                best_match = None
                highest_score = 0
                for item in results['tracks']['items']:
                    spotify_name = normalize_string(item['name'])
                    spotify_artist = normalize_string(item['artists'][0]['name'])
                    name_score = fuzz.token_sort_ratio(name, spotify_name)
                    artist_score = fuzz.token_sort_ratio(artist, spotify_artist)
                    total_score = (name_score + artist_score) / 2
                    if total_score > highest_score:
                        highest_score = total_score
                        best_match = item['id']
                if highest_score > 80:  # Threshold can be adjusted
                    return best_match
            return None
        except spotipy.exceptions.SpotifyException as e:
            logging.error(f"Spotify API error: {e}")
            time.sleep(2)  # Wait before retrying
            return None
        finally:
            time.sleep(0.1)  # Small delay to respect rate limits

    def get_cached_track_id(self, name, artist):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT track_id FROM search_cache WHERE name = ? AND artist = ?", (name, artist))
        result = c.fetchone()
        conn.close()
        if result:
            return result[0] if result[0] != 'NOT_FOUND' else None
        return None

    def cache_track_id(self, name, artist, track_id):
        if track_id is None:
            track_id = 'NOT_FOUND'
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("INSERT OR REPLACE INTO search_cache (name, artist, track_id) VALUES (?, ?, ?)",
                  (name, artist, track_id))
        conn.commit()
        conn.close()

    def find_tracks_to_like(self, lastfm_tracks, min_play_count=5):
        spotify_liked = self.get_liked_songs_set()
        tracks_to_like = []
        processed_tracks = []

        for track in lastfm_tracks:
            if track[2] >= min_play_count:
                name, artist, play_count = track[1], track[0], track[2]
                processed_tracks.append((artist, name, play_count))

                logging.info(f"Checking track: {artist} - {name} (Play count: {play_count})")

                if not self.is_track_liked(name, artist, spotify_liked):
                    logging.info(f"Track not liked on Spotify: {artist} - {name}")
                    track_id = self.search_track(name, artist)
                    if track_id:
                        if not self.is_track_in_database(track_id):
                            tracks_to_like.append(track_id)
                            logging.info(f"Will like: {artist} - {name}")
                        else:
                            logging.info(f"Track already in database, skipping: {artist} - {name}")
                    else:
                        logging.info(f"Couldn't find track on Spotify: {artist} - {name}")
                        self.add_unfound_track(artist, name)
                else:
                    logging.info(f"Track already liked, skipping: {artist} - {name}")
            else:
                logging.info(f"Skipping track with low play count: {track[0]} - {track[1]} (Play count: {track[2]})")
                break

        # Mark processed tracks in the Last.fm database
        lastfm_db = Database(db_file=LASTFM_DB_FILE)
        lastfm_db.mark_tracks_as_processed(processed_tracks)

        logging.info(f"Found {len(processed_tracks)} tracks with {min_play_count}+ plays on Last.fm")
        logging.info(f"Of these, {len(tracks_to_like)} are new tracks to like on Spotify")
        return tracks_to_like

    def is_track_liked(self, name, artist, spotify_liked):
        normalized_name = normalize_string(name)
        normalized_artist = normalize_string(artist)
        return any(
            fuzz.ratio(normalized_name, liked_name) > 90 and
            fuzz.ratio(normalized_artist, liked_artist) > 90
            for liked_name, liked_artist in spotify_liked
        )

    def is_track_in_database(self, track_id):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT id FROM liked_songs WHERE id = ?", (track_id,))
        result = c.fetchone()
        conn.close()
        return result is not None

    def add_unfound_track(self, artist, name):
        """Add a track that couldn't be found on Spotify to the unfound_tracks table."""
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("INSERT OR IGNORE INTO unfound_tracks (artist, name) VALUES (?, ?)", (artist, name))
        conn.commit()
        conn.close()

    def get_last_update_time(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT value FROM metadata WHERE key = 'last_update'")
        result = c.fetchone()
        conn.close()
        if result and result[0]:
            # Ensure the datetime is timezone-aware and in UTC
            return datetime.fromisoformat(result[0]).astimezone(timezone.utc)
        return None

    def set_last_update_time(self, update_time):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        # Ensure update_time is in ISO format with timezone info
        c.execute("INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)",
                  ('last_update', update_time.astimezone(timezone.utc).isoformat()))
        conn.commit()
        conn.close()

    def fetch_new_liked_songs(self):
        last_update = self.get_last_update_time()
        offset = 0
        limit = 50
        new_tracks = []

        while True:
            results = self.sp.current_user_saved_tracks(limit=limit, offset=offset)
            if not results['items']:
                break
            for item in results['items']:
                added_at = datetime.strptime(item['added_at'], "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
                if last_update and added_at <= last_update:
                    # Since the list is in descending order, we can stop here
                    return new_tracks
                new_tracks.append(item)
            offset += limit
        return new_tracks

    def update_liked_songs(self, force_full_fetch=False):
        last_update = self.get_last_update_time()
        if last_update is None or force_full_fetch:
            logging.info("Fetching all liked songs from Spotify.")
            total_tracks = self.fetch_all_liked_songs()
            logging.info(f"Fetched {total_tracks} liked songs from Spotify.")
            self.set_last_update_time(datetime.now(timezone.utc))
            
            # Add logging to verify database update
            conn = sqlite3.connect(self.db_file)
            c = conn.cursor()
            c.execute("SELECT COUNT(*) FROM liked_songs")
            total_liked_songs = c.fetchone()[0]
            conn.close()
            logging.info(f"Total liked songs in local database: {total_liked_songs}")
            
            return total_tracks
        else:
            new_tracks = self.fetch_new_liked_songs()
            if not new_tracks:
                logging.info("No new liked songs to update.")
                return 0
            self._save_tracks_to_db(new_tracks)
            latest_added_at = max(
                datetime.strptime(item['added_at'], "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
                for item in new_tracks
            )
            self.set_last_update_time(latest_added_at)
            logging.info(f"Updated last update time to: {latest_added_at.isoformat()}")
            
            # Add logging to verify database update
            conn = sqlite3.connect(self.db_file)
            c = conn.cursor()
            c.execute("SELECT COUNT(*) FROM liked_songs")
            total_liked_songs = c.fetchone()[0]
            conn.close()
            logging.info(f"Total liked songs in local database after update: {total_liked_songs}")
            
            return len(new_tracks)

    def _save_tracks_to_db(self, tracks):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        for item in tracks:
            track = item['track']
            name = normalize_string(track['name'])
            artist = normalize_string(track['artists'][0]['name'])
            album = normalize_string(track['album']['name'])
            album_id = track['album']['id']
            c.execute("INSERT OR REPLACE INTO liked_songs VALUES (?, ?, ?, ?, ?, ?)",
                      (track['id'], name, artist, album, album_id, item['added_at']))
        conn.commit()
        conn.close()

    def verify_local_database(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT COUNT(*) FROM liked_songs")
        count = c.fetchone()[0]
        logging.info(f"Local database contains {count} liked songs")
        c.execute("SELECT name, artist FROM liked_songs LIMIT 5")
        sample = c.fetchall()
        logging.info(f"Sample of liked songs in database: {sample}")
        conn.close()

    def log_unfound_tracks(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT artist, name FROM unfound_tracks")
        unfound = c.fetchall()
        conn.close()
        logging.info(f"Unfound tracks in database: {len(unfound)}")
        for artist, name in unfound[:5]:  # Log first 5 for brevity
            logging.info(f"Unfound: {artist} - {name}")

    def get_all_album_ids(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT DISTINCT album_id FROM liked_songs")
        album_ids = [row[0] for row in c.fetchall()]
        conn.close()
        return album_ids

    def get_album_ids_since(self, since_datetime):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT DISTINCT album_id FROM liked_songs WHERE added_at > ?",
                  (since_datetime.isoformat(),))
        album_ids = [row[0] for row in c.fetchall()]
        conn.close()
        return album_ids

File: src/scripts/album_saver.py
================================

# album_saver.py

import os
import sys

# Modify the sys.path to include the project root
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
sys.path.insert(0, project_root)

from src.database import Database
from src.spotify_operations import SpotifyOperations
from src.utils import normalize_string

import logging
import sqlite3
from datetime import datetime, timezone
from dotenv import load_dotenv
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import random

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',
                    filename='logs/album_saver.log', filemode='a')

# Load environment variables
load_dotenv()

LASTFM_DB_FILE = os.getenv('LASTFM_DB_FILE', 'db/lastfm_history.db')
SPOTIFY_DB_FILE = os.getenv('SPOTIFY_DB_FILE', 'db/spotify_liked_songs.db')
ALBUM_SAVER_DB_FILE = os.getenv('ALBUM_SAVER_DB_FILE', 'db/album_saver.db')

class AlbumSaver:
    def __init__(self):
        self.lastfm_db = Database(db_file=LASTFM_DB_FILE)
        self.spotify_ops = SpotifyOperations(db_file=SPOTIFY_DB_FILE)
        self.sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope="user-library-read user-library-modify"))
        self.create_album_saver_table()

    def create_album_saver_table(self):
        conn = sqlite3.connect(ALBUM_SAVER_DB_FILE)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS saved_albums
                     (id TEXT PRIMARY KEY, name TEXT, artist TEXT, last_checked DATETIME)''')
        c.execute('''CREATE TABLE IF NOT EXISTS metadata
                     (key TEXT PRIMARY KEY, value TEXT)''')
        conn.commit()
        conn.close()

    def get_album_tracks(self, album_id):
        tracks = []
        results = self.sp.album_tracks(album_id)
        tracks.extend(results['items'])
        while results['next']:
            results = self.sp.next(results)
            tracks.extend(results['items'])
        return tracks

    def check_album_conditions(self, album_id):
        album = self.sp.album(album_id)
        if 'various artists' in album['artists'][0]['name'].lower():
            return False

        album_tracks = self.get_album_tracks(album_id)
        total_tracks = len(album_tracks)
        
        if total_tracks <= 3:
            return False  # Don't add albums with 3 or fewer tracks

        listened_tracks = 0
        tracks_listened_3_times = 0

        for track in album_tracks:
            listen_count = self.get_track_listen_count(track['name'], track['artists'][0]['name'])
            if listen_count > 0:
                listened_tracks += 1
            if listen_count >= 3:
                tracks_listened_3_times += 1

        if total_tracks <= 6:
            return listened_tracks == total_tracks  # All tracks must be listened to at least once

        # For albums with 7 or more tracks
        condition1 = listened_tracks >= 0.75 * total_tracks
        condition2 = tracks_listened_3_times >= 3

        return condition1 or condition2

    def get_track_listen_count(self, track_name, artist_name):
        normalized_track = normalize_string(track_name)
        normalized_artist = normalize_string(artist_name)
        
        conn = sqlite3.connect(LASTFM_DB_FILE)
        c = conn.cursor()
        c.execute("SELECT listen_count FROM tracks WHERE name = ? AND artist = ?", 
                  (normalized_track, normalized_artist))
        result = c.fetchone()
        conn.close()

        return result[0] if result else 0

    def save_album_to_library(self, album_id):
        try:
            album = self.sp.album(album_id)
            album_name = album['name']
            artist_name = album['artists'][0]['name']

            # Check for duplicates
            duplicates = self.get_duplicate_albums(album_name, artist_name)
            if duplicates:
                chosen_album = self.choose_album_to_keep(duplicates + [album_id])
                if chosen_album != album_id:
                    logging.info(f"Not saving album {album_id} as a better version exists")
                    return
                else:
                    # Remove other duplicates
                    for dup in duplicates:
                        if dup != album_id:
                            self.sp.current_user_saved_albums_delete([dup])
                            logging.info(f"Removed duplicate album {dup}")

            self.sp.current_user_saved_albums_add([album_id])
            logging.info(f"Saved album {album_id} to library")
            self.update_saved_album(album_id, album_name, artist_name)
        except Exception as e:
            logging.error(f"Error saving album {album_id}: {e}")

    def get_duplicate_albums(self, album_name, artist_name):
        conn = sqlite3.connect(ALBUM_SAVER_DB_FILE)
        c = conn.cursor()
        c.execute("SELECT id FROM saved_albums WHERE name = ? AND artist = ?", (album_name, artist_name))
        duplicates = [row[0] for row in c.fetchall()]
        conn.close()
        return duplicates

    def choose_album_to_keep(self, album_ids):
        max_liked_songs = -1
        albums_with_max = []

        for album_id in album_ids:
            liked_songs = self.count_liked_songs(album_id)
            if liked_songs > max_liked_songs:
                max_liked_songs = liked_songs
                albums_with_max = [album_id]
            elif liked_songs == max_liked_songs:
                albums_with_max.append(album_id)

        return random.choice(albums_with_max)

    def count_liked_songs(self, album_id):
        tracks = self.get_album_tracks(album_id)
        liked_count = 0
        for track in tracks:
            if self.sp.current_user_saved_tracks_contains([track['id']])[0]:
                liked_count += 1
        return liked_count

    def update_saved_album(self, album_id, album_name, artist_name):
        conn = sqlite3.connect(ALBUM_SAVER_DB_FILE)
        c = conn.cursor()
        now = datetime.now(timezone.utc).isoformat()
        c.execute("INSERT OR REPLACE INTO saved_albums (id, name, artist, last_checked) VALUES (?, ?, ?, ?)",
                  (album_id, album_name, artist_name, now))
        conn.commit()
        conn.close()

    def get_last_update_time(self):
        conn = sqlite3.connect(ALBUM_SAVER_DB_FILE)
        c = conn.cursor()
        c.execute("SELECT value FROM metadata WHERE key = 'last_update'")
        result = c.fetchone()
        conn.close()
        if result and result[0]:
            return datetime.fromisoformat(result[0]).astimezone(timezone.utc)
        return None

    def set_last_update_time(self, update_time):
        conn = sqlite3.connect(ALBUM_SAVER_DB_FILE)
        c = conn.cursor()
        c.execute("INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)",
                  ('last_update', update_time.astimezone(timezone.utc).isoformat()))
        conn.commit()
        conn.close()

    def process_albums(self, force_full_check=False):
        last_update = self.get_last_update_time()
        
        if last_update is None or force_full_check:
            logging.info("Performing full album check")
            album_ids = self.spotify_ops.get_all_album_ids()
        else:
            logging.info(f"Checking albums updated since {last_update}")
            album_ids = self.spotify_ops.get_album_ids_since(last_update)

        for album_id in album_ids:
            if self.check_album_conditions(album_id):
                self.save_album_to_library(album_id)
            else:
                album = self.sp.album(album_id)
                self.update_saved_album(album_id, album['name'], album['artists'][0]['name'])  # Mark as checked even if not saved

        self.set_last_update_time(datetime.now(timezone.utc))

def main():
    try:
        album_saver = AlbumSaver()
        force_full_check = len(sys.argv) > 1 and sys.argv[1] == '--full'
        album_saver.process_albums(force_full_check)
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()

File: src/scripts/spotify_deduplicator.py
=========================================

import os
import sys

# Modify the sys.path to include the project root
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
sys.path.insert(0, project_root)

from src.utils import normalize_string

import logging
import time
from datetime import datetime, timezone
import sqlite3
from dotenv import load_dotenv
import spotipy
from spotipy.oauth2 import SpotifyOAuth
from rapidfuzz import fuzz, process

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',
                    filename='logs/spotify_deduplicator.log', filemode='a')

# Load environment variables
load_dotenv()

# Database file path
SPOTIFY_DB_FILE = os.getenv('SPOTIFY_DB_FILE', 'db/spotify_liked_songs.db')

class SpotifyDeduplicator:
    def __init__(self):
        self.sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope="user-library-read user-library-modify"))

    def fetch_all_liked_songs(self):
        offset = 0
        limit = 50
        all_tracks = []

        while True:
            results = self.sp.current_user_saved_tracks(limit=limit, offset=offset)
            tracks = results['items']
            if len(tracks) == 0:
                break
            all_tracks.extend(tracks)
            offset += limit

        logging.info(f"Fetched {len(all_tracks)} liked songs from Spotify.")
        return all_tracks

    def group_duplicates(self, tracks):
        track_map = {}
        for item in tracks:
            track = item['track']
            name = normalize_string(track['name'])
            artist = normalize_string(track['artists'][0]['name'])
            key = f"{artist} {name}"
            if key not in track_map:
                track_map[key] = []
            track_map[key].append(track)
        duplicates = {k: v for k, v in track_map.items() if len(v) > 1}
        logging.info(f"Found {len(duplicates)} groups of duplicate tracks.")
        return duplicates

    def select_preferred_track(self, tracks):
        # Apply your rules to select the preferred track
        # Rule 1: Prefer remastered versions
        remastered_tracks = [t for t in tracks if 'remaster' in t['name'].lower()]
        if remastered_tracks:
            tracks = remastered_tracks

        # Rule 2: Prefer tracks from deluxe/longer albums
        if len(tracks) > 1:
            album_lengths = {}
            for t in tracks:
                album_id = t['album']['id']
                if album_id not in album_lengths:
                    album = self.sp.album(album_id)
                    album_lengths[album_id] = len(album['tracks']['items'])
                t['album_length'] = album_lengths[album_id]
            max_length = max(t['album_length'] for t in tracks)
            tracks = [t for t in tracks if t['album_length'] == max_length]

        # Return the first track if multiple remain
        return tracks[0]

    def deduplicate(self):
        all_tracks = self.fetch_all_liked_songs()
        duplicates = self.group_duplicates(all_tracks)
        tracks_to_remove = []
        for key, tracks in duplicates.items():
            preferred_track = self.select_preferred_track(tracks)
            for t in tracks:
                if t['id'] != preferred_track['id']:
                    tracks_to_remove.append(t['id'])
                    logging.info(f"Removing duplicate track: {t['name']} by {t['artists'][0]['name']}")
        if tracks_to_remove:
            batch_size = 50
            for i in range(0, len(tracks_to_remove), batch_size):
                batch = tracks_to_remove[i:i+batch_size]
                retry_count = 0
                while retry_count < 3:  # Maximum 3 retries
                    try:
                        self.sp.current_user_saved_tracks_delete(tracks=batch)
                        break  # Success, exit the retry loop
                    except spotipy.exceptions.SpotifyException as e:
                        if e.http_status == 429:
                            retry_after = int(e.headers.get('Retry-After', 5))
                            logging.warning(f"Rate limited by Spotify. Retrying after {retry_after} seconds.")
                            time.sleep(retry_after)
                            retry_count += 1
                        else:
                            logging.error(f"Error removing tracks: {e}")
                            break  # Exit the retry loop for non-rate-limiting errors
                    except Exception as e:
                        logging.error(f"Unexpected error removing tracks: {e}")
                        break
                time.sleep(0.1)
            logging.info(f"Removed {len(tracks_to_remove)} duplicate tracks.")
        else:
            logging.info("No duplicates found to remove.")

def main():
    try:
        deduplicator = SpotifyDeduplicator()
        deduplicator.deduplicate()
    except KeyboardInterrupt:
        logging.info("Program interrupted by user. Exiting gracefully.")
        sys.exit(0)
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()


File: src/scripts/__init__.py
=============================



File: src/scripts/lastfm_spotify_liker.py
=========================================

import os
import sys

# Modify the sys.path to include the project root
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
sys.path.insert(0, project_root)

import logging
import time
import sqlite3
from datetime import datetime, timezone
import requests
from dotenv import load_dotenv

from src.database import Database
from src.spotify_operations import SpotifyOperations
from src.utils import normalize_string

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.FileHandler('logs/lastfm_spotify_liker.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

# Load environment variables
load_dotenv()

# Last.fm API credentials
LASTFM_API_KEY = os.getenv('LASTFM_API_KEY')
LASTFM_USER = os.getenv('LASTFM_USER')
MIN_PLAY_COUNT = int(os.getenv('MIN_PLAY_COUNT', 5))

# Database file paths
LASTFM_DB_FILE = os.getenv('LASTFM_DB_FILE', 'db/lastfm_history.db')
SPOTIFY_DB_FILE = os.getenv('SPOTIFY_DB_FILE', 'db/spotify_liked_songs.db')

def get_new_lastfm_tracks(db, from_timestamp=None):
    url = 'http://ws.audioscrobbler.com/2.0/'
    params = {
        'method': 'user.getrecenttracks',
        'user': LASTFM_USER,
        'api_key': LASTFM_API_KEY,
        'format': 'json',
        'limit': 200,
        'from': from_timestamp
    }

    all_tracks = []
    page = 1
    total_pages = 1

    while True:
        params['page'] = page
        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
            data = response.json()

            if 'error' in data:
                logging.error(f"Error fetching Last.fm tracks: {data['message']}")
                break

            tracks = data['recenttracks']['track']
            if not isinstance(tracks, list):
                tracks = [tracks]
            all_tracks.extend(tracks)

            total_pages = int(data['recenttracks']['@attr'].get('totalPages', 1))
            logging.info(f"Fetched page {page} of {total_pages}")

            if page >= total_pages:
                break
            page += 1

        except requests.RequestException as e:
            logging.error(f"Network error when fetching Last.fm tracks: {e}")
            break
        except Exception as e:
            logging.error(f"Unexpected error in get_new_lastfm_tracks: {e}")
            logging.exception(e)
            break

    for track in all_tracks:
        try:
            if 'date' in track:
                track['date'] = datetime.fromtimestamp(int(track['date']['uts'])).replace(tzinfo=timezone.utc)
            else:
                track['date'] = datetime.now(timezone.utc)  # For 'now playing' track

            # Safely extract artist name
            artist_name = track['artist']['#text'] if isinstance(track['artist'], dict) else track['artist']

            # Safely extract album name
            album_name = track['album']['#text'] if isinstance(track['album'], dict) else track['album']

            # Safely extract track name
            track_name = track['name']['#text'] if isinstance(track['name'], dict) else track['name']

            db.add_or_update_track({
                'artist': artist_name,
                'name': track_name,
                'album': album_name,
                'date': track['date'],
                'mbid': track.get('mbid', '')
            })
        except Exception as e:
            logging.error(f"Error processing track: {track}")
            logging.exception(e)
            continue

    return len(all_tracks)

def main():
    try:
        lastfm_db = Database(db_file=LASTFM_DB_FILE)
        spotify_ops = SpotifyOperations(db_file=SPOTIFY_DB_FILE)
        
        # Ensure the processed column exists
        lastfm_db.add_processed_column()
        
        spotify_ops.verify_local_database()  # Verify database at the start
        
        # Check for and remove duplicates
        spotify_ops.remove_duplicates()
        
        # Update Last.fm tracks
        last_update = lastfm_db.get_last_update_time()
        if last_update:
            logging.info(f"Fetching Last.fm tracks since {last_update}")
            new_tracks_count = get_new_lastfm_tracks(lastfm_db, int(last_update.timestamp()))
        else:
            logging.info("Fetching all Last.fm tracks (first run)")
            new_tracks_count = get_new_lastfm_tracks(lastfm_db)

        logging.info(f"Added or updated {new_tracks_count} tracks from Last.fm")

        # Update Spotify liked songs
        logging.info("Updating Spotify liked songs...")
        new_liked_songs_count = spotify_ops.update_liked_songs()
        logging.info(f"Added {new_liked_songs_count} new liked songs to the Spotify database")

        # Get frequently played tracks from Last.fm
        frequently_played = lastfm_db.get_frequently_played_tracks(MIN_PLAY_COUNT)
        logging.info(f"Found {len(frequently_played)} tracks played more than {MIN_PLAY_COUNT} times on Last.fm")

        # Find tracks to be liked
        tracks_to_like = spotify_ops.find_tracks_to_like(frequently_played, min_play_count=MIN_PLAY_COUNT)
        
        if tracks_to_like:
            logging.info(f"Found {len(tracks_to_like)} new tracks to like on Spotify:")
            for track_id in tracks_to_like:
                track_info = spotify_ops.sp.track(track_id)
                logging.info(f"  - {track_info['artists'][0]['name']} - {track_info['name']}")
            
            # Like the tracks on Spotify
            spotify_ops.like_tracks(tracks_to_like)
            logging.info(f"Finished liking {len(tracks_to_like)} tracks on Spotify")
        else:
            logging.info("No new tracks to like on Spotify")

        # Update Spotify liked songs again to ensure local database is current
        spotify_ops.update_liked_songs()
        
        # Check for and remove duplicates again
        spotify_ops.remove_duplicates()
        
        spotify_ops.verify_local_database()  # Verify database at the end

    except sqlite3.OperationalError as e:
        logging.error(f"Database error: {e}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        raise

if __name__ == "__main__":
    main()


File: src/scripts/remove_duplicate_albums.py
============================================

# remove_duplicate_albums.py

import os
import sys

# Modify the sys.path to include the project root
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
sys.path.insert(0, project_root)

import spotipy
from spotipy.oauth2 import SpotifyOAuth
from dotenv import load_dotenv
import random
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',
                    filename='logs/remove_duplicate_albums.log', filemode='a')

# Load environment variables from .env file
load_dotenv()

# Set up Spotify client
SPOTIPY_CLIENT_ID = os.getenv('SPOTIPY_CLIENT_ID')
SPOTIPY_CLIENT_SECRET = os.getenv('SPOTIPY_CLIENT_SECRET')
SPOTIPY_REDIRECT_URI = os.getenv('SPOTIPY_REDIRECT_URI')

print(f"SPOTIPY_CLIENT_ID: {SPOTIPY_CLIENT_ID}")
print(f"SPOTIPY_CLIENT_SECRET: {SPOTIPY_CLIENT_SECRET}")
print(f"SPOTIPY_REDIRECT_URI: {SPOTIPY_REDIRECT_URI}")

if not SPOTIPY_CLIENT_ID or not SPOTIPY_CLIENT_SECRET or not SPOTIPY_REDIRECT_URI:
    raise ValueError("Spotify credentials not found in .env file.")

def get_spotify_client():
    return spotipy.Spotify(auth_manager=SpotifyOAuth(scope="user-library-read user-library-modify"))

def get_albums_to_remove(sp):
    albums_to_remove = []
    offset = 0
    batch_size = 50
    album_dict = {}

    while True:
        results = sp.current_user_saved_albums(limit=batch_size, offset=offset)
        if not results['items']:
            break
        
        for item in results['items']:
            album = item['album']
            artist = album['artists'][0]['name']
            album_name = album['name']
            album_id = album['id']

            if 'various artists' in artist.lower():
                albums_to_remove.append((album_id, album_name, artist))
            else:
                key = f"{artist.lower()}:{album_name.lower()}"
                if key in album_dict:
                    album_dict[key].append((album_id, album_name, artist))
                else:
                    album_dict[key] = [(album_id, album_name, artist)]
        
        offset += batch_size

    # Check for duplicates
    for albums in album_dict.values():
        if len(albums) > 1:
            albums_to_keep = choose_albums_to_keep(sp, albums)
            albums_to_remove.extend([album for album in albums if album not in albums_to_keep])

    return albums_to_remove

def choose_albums_to_keep(sp, albums):
    deluxe = None
    remastered = None
    normal = None
    max_liked_songs = -1
    albums_with_max = []

    for album in albums:
        album_id, album_name, _ = album
        if 'deluxe' in album_name.lower():
            deluxe = album
        elif 'remaster' in album_name.lower():
            remastered = album
        else:
            normal = album

        liked_songs = count_liked_songs(sp, album_id)
        if liked_songs > max_liked_songs:
            max_liked_songs = liked_songs
            albums_with_max = [album]
        elif liked_songs == max_liked_songs:
            albums_with_max.append(album)

    to_keep = []
    if deluxe:
        to_keep.append(deluxe)
    if remastered and remastered not in to_keep:
        to_keep.append(remastered)
    if normal and normal not in to_keep:
        to_keep.append(normal)

    if not to_keep:
        to_keep = [random.choice(albums_with_max)]

    return to_keep

def count_liked_songs(sp, album_id):
    tracks = sp.album_tracks(album_id)['items']
    liked_count = 0
    for track in tracks:
        if sp.current_user_saved_tracks_contains([track['id']])[0]:
            liked_count += 1
    return liked_count

def remove_albums(sp, albums_to_remove):
    for i in range(0, len(albums_to_remove), 50):
        batch = albums_to_remove[i:i+50]
        sp.current_user_saved_albums_delete([album[0] for album in batch])
        for album in batch:
            print(f"Removed: {album[2]} - {album[1]}")

def main():
    sp = get_spotify_client()
    
    print("Searching for albums to remove...")
    albums_to_remove = get_albums_to_remove(sp)
    
    if albums_to_remove:
        print(f"Found {len(albums_to_remove)} albums to remove:")
        for album in albums_to_remove:
            print(f"  {album[2]} - {album[1]}")
        confirm = input("Do you want to remove these albums? (y/n): ")
        if confirm.lower() == 'y':
            remove_albums(sp, albums_to_remove)
            print(f"Total albums removed: {len(albums_to_remove)}")
        else:
            print("Operation cancelled.")
    else:
        print("No albums to remove found in your library.")

if __name__ == "__main__":
    main()

File: src/scripts/hot_100_playlist.py
=====================================

import os
import sys
import re
import sqlite3
import logging
import random
import requests
from datetime import datetime, timedelta
from dotenv import load_dotenv
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import unicodedata

# Modify the sys.path to include the project root
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
sys.path.insert(0, project_root)

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',
                    filename='logs/hot_100_playlist.log', filemode='a')

# Load environment variables
load_dotenv()

# Last.fm API credentials
LASTFM_API_KEY = os.getenv('LASTFM_API_KEY')
LASTFM_USER = os.getenv('LASTFM_USER')

# Spotify API credentials
SPOTIFY_CLIENT_ID = os.getenv('SPOTIFY_CLIENT_ID')
SPOTIFY_CLIENT_SECRET = os.getenv('SPOTIFY_CLIENT_SECRET')
SPOTIFY_REDIRECT_URI = os.getenv('SPOTIPY_REDIRECT_URI')

# Database file paths
LASTFM_100_DAYS_DB = 'db/lastfm_100_days.db'
PLAYLIST_NAME = "Bobby's Hot ðŸ’¯"
PLAYLIST_ID_FILE = 'playlist_id.txt'

class LastFM100DaysDB:
    def __init__(self, db_file):
        self.db_file = db_file
        self.create_table()

    def create_table(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS tracks
                     (id INTEGER PRIMARY KEY AUTOINCREMENT,
                      artist TEXT,
                      name TEXT,
                      album TEXT,
                      play_count INTEGER,
                      last_played TEXT,
                      UNIQUE(artist, name, album))''')
        conn.commit()
        conn.close()

    def update_tracks(self, tracks):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        for track in tracks:
            c.execute('''SELECT play_count, last_played FROM tracks
                         WHERE artist = ? AND name = ? AND album = ?''',
                      (track['artist'], track['name'], track['album']))
            result = c.fetchone()
            if result:
                existing_play_count, existing_last_played = result
                # Convert existing_last_played from string to datetime
                existing_last_played = datetime.fromisoformat(existing_last_played)
                new_play_count = existing_play_count + track['play_count']
                new_last_played = max(existing_last_played, track['last_played'])
                # Convert new_last_played to ISO string for storage
                new_last_played_str = new_last_played.isoformat()
                c.execute('''UPDATE tracks
                             SET play_count = ?, last_played = ?
                             WHERE artist = ? AND name = ? AND album = ?''',
                          (new_play_count, new_last_played_str, track['artist'], track['name'], track['album']))
            else:
                # Convert last_played to ISO string for storage
                last_played_str = track['last_played'].isoformat()
                c.execute('''INSERT INTO tracks (artist, name, album, play_count, last_played)
                             VALUES (?, ?, ?, ?, ?)''',
                          (track['artist'], track['name'], track['album'], track['play_count'], last_played_str))
        conn.commit()
        conn.close()

    def remove_old_tracks(self, cut_off_date):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        # Convert cut_off_date to ISO string for comparison
        cut_off_date_str = cut_off_date.isoformat()
        c.execute("DELETE FROM tracks WHERE last_played < ?", (cut_off_date_str,))
        conn.commit()
        conn.close()

    def get_all_tracks(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute('''SELECT artist, name, album, play_count FROM tracks
                     ORDER BY play_count DESC, last_played DESC''')
        all_tracks = c.fetchall()
        conn.close()
        return all_tracks

def get_lastfm_tracks(from_date, to_date):
    url = 'http://ws.audioscrobbler.com/2.0/'
    params = {
        'method': 'user.getrecenttracks',
        'user': LASTFM_USER,
        'api_key': LASTFM_API_KEY,
        'format': 'json',
        'limit': 200,
        'from': int(from_date.timestamp()),
        'to': int(to_date.timestamp())
    }

    all_tracks = []
    page = 1

    while True:
        params['page'] = page
        response = requests.get(url, params=params)
        data = response.json()

        if 'error' in data:
            logging.error(f"Error fetching Last.fm tracks: {data['message']}")
            break

        tracks = data['recenttracks']['track']
        all_tracks.extend(tracks)

        total_pages = int(data['recenttracks']['@attr']['totalPages'])
        if page >= total_pages:
            break
        page += 1

    return all_tracks

def process_lastfm_tracks(tracks):
    processed_tracks = {}
    for track in tracks:
        if 'date' not in track:
            # Skip currently playing track
            continue

        artist = track['artist']['#text']
        name = track['name']
        album = track['album']['#text'] if 'album' in track and track['album']['#text'] else 'Unknown Album'
        date = datetime.fromtimestamp(int(track['date']['uts']))

        key = (artist, name, album)
        if key in processed_tracks:
            processed_tracks[key]['play_count'] += 1
            processed_tracks[key]['last_played'] = max(processed_tracks[key]['last_played'], date)
        else:
            processed_tracks[key] = {
                'artist': artist,
                'name': name,
                'album': album,
                'play_count': 1,
                'last_played': date
            }

    return list(processed_tracks.values())

def normalize_string(s):
    # Convert to lowercase
    s = s.lower()
    # Remove content inside parentheses
    s = re.sub(r'\(.*?\)', '', s)
    # Remove extra spaces
    s = ' '.join(s.strip().split())
    # Remove punctuation except ampersand
    s = re.sub(r'[^\w\s&]', '', s)
    return s

def get_or_create_playlist(sp, name):
    playlist_id_file = PLAYLIST_ID_FILE

    # Check if playlist ID is stored in file
    if os.path.exists(playlist_id_file):
        with open(playlist_id_file, 'r') as f:
            playlist_id = f.read().strip()
        # Verify that the playlist still exists and is accessible
        try:
            playlist = sp.playlist(playlist_id)
            if playlist['name'] == name:
                logging.info(f"Found existing playlist by ID: {playlist['name']}")
                return playlist_id
            else:
                logging.warning(f"Playlist ID found but name doesn't match. Updating name and using playlist.")
                # Optionally update the playlist name to match
                sp.user_playlist_change_details(sp.me()['id'], playlist_id, name=name)
                return playlist_id
        except spotipy.exceptions.SpotifyException as e:
            logging.warning(f"Playlist ID not valid or playlist not found. Creating new playlist.")

    # Playlist ID not found or invalid, create a new playlist
    logging.info(f"Playlist '{name}' not found. Creating new playlist.")
    user_id = sp.me()['id']
    playlist = sp.user_playlist_create(user_id, name, public=False)
    # Store the new playlist ID
    with open(playlist_id_file, 'w') as f:
        f.write(playlist['id'])
    return playlist['id']

def update_playlist(sp, playlist_id, track_ids):
    logging.info(f"Updating playlist {playlist_id} with {len(track_ids)} tracks")

    # Randomize the order of tracks
    random.shuffle(track_ids)

    # Clear the playlist first
    sp.playlist_replace_items(playlist_id, [])
    # Spotify API allows up to 100 tracks per request
    for i in range(0, len(track_ids), 100):
        sp.playlist_add_items(playlist_id, track_ids[i:i+100])
    logging.info("Playlist update completed with randomized order")

def main():
    # Initialize Spotify client
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope="playlist-modify-private,playlist-modify-public"))

    # Initialize Last.fm 100 days database
    lastfm_db = LastFM100DaysDB(LASTFM_100_DAYS_DB)

    # Calculate date range
    end_date = datetime.now()
    start_date = end_date - timedelta(days=100)

    # Fetch Last.fm tracks
    lastfm_tracks = get_lastfm_tracks(start_date, end_date)
    processed_tracks = process_lastfm_tracks(lastfm_tracks)

    # Update database
    lastfm_db.update_tracks(processed_tracks)
    lastfm_db.remove_old_tracks(start_date)

    # Get all tracks sorted by play count descending
    all_tracks = lastfm_db.get_all_tracks()

    # Build a dictionary to keep track of the album with the highest play count for each (artist, name)
    track_album_playcount = {}
    for artist, name, album, play_count in all_tracks:
        norm_artist = normalize_string(artist)
        norm_name = normalize_string(name)
        key = (norm_artist, norm_name)
        if key not in track_album_playcount:
            track_album_playcount[key] = {
                'artist': artist,
                'name': name,
                'album': album,
                'play_count': play_count
            }
        else:
            if play_count > track_album_playcount[key]['play_count']:
                track_album_playcount[key] = {
                    'artist': artist,
                    'name': name,
                    'album': album,
                    'play_count': play_count
                }

    # Now, get the top 100 tracks based on play count
    sorted_tracks = sorted(track_album_playcount.values(), key=lambda x: x['play_count'], reverse=True)

    # Build the list of tracks to add to the playlist
    spotify_track_ids = []
    track_count = 0
    for track_info in sorted_tracks:
        if track_count >= 100:
            break

        artist = track_info['artist']
        name = track_info['name']
        album = track_info['album']
        play_count = track_info['play_count']

        logging.info(f"Searching for track: {artist} - {name} (Album: {album}, Play count: {play_count})")

        # Try to find the track on Spotify
        found = False
        queries = [
            f'track:"{name}" artist:"{artist}" album:"{album}"',
            f'track:"{name}" artist:"{artist}"',
            f'track:"{name}"',
        ]
        for query in queries:
            results = sp.search(q=query, type='track', limit=5)
            if results['tracks']['items']:
                # Try to find the best match
                for item in results['tracks']['items']:
                    spotify_track = item['name']
                    spotify_artist = item['artists'][0]['name']
                    spotify_album = item['album']['name']
                    # Normalize the names
                    norm_spotify_artist = normalize_string(spotify_artist)
                    norm_spotify_name = normalize_string(spotify_track)
                    norm_spotify_album = normalize_string(spotify_album)
                    norm_artist = normalize_string(artist)
                    norm_name = normalize_string(name)
                    norm_album = normalize_string(album)
                    if norm_spotify_artist == norm_artist and norm_spotify_name == norm_name and norm_spotify_album == norm_album:
                        spotify_track_ids.append(item['id'])
                        found = True
                        track_count += 1
                        logging.info(f"Found exact match: {spotify_artist} - {spotify_track} ({spotify_album})")
                        break
                if found:
                    break
        if not found:
            logging.warning(f"Could not find exact match on Spotify: {artist} - {name} ({album})")
            # Try to find the best available version
            for query in queries:
                results = sp.search(q=query, type='track', limit=5)
                if results['tracks']['items']:
                    item = results['tracks']['items'][0]
                    spotify_track_ids.append(item['id'])
                    track_count += 1
                    logging.info(f"Added closest match: {item['artists'][0]['name']} - {item['name']} ({item['album']['name']})")
                    found = True
                    break

    # Ensure we only have 100 tracks
    spotify_track_ids = spotify_track_ids[:100]

    # Get or create playlist
    playlist_id = get_or_create_playlist(sp, PLAYLIST_NAME)

    # Update playlist with randomized order
    update_playlist(sp, playlist_id, spotify_track_ids)

    logging.info(f"Playlist '{PLAYLIST_NAME}' updated with {len(spotify_track_ids)} tracks in random order.")

    # Get the playlist link
    playlist_info = sp.playlist(playlist_id)
    playlist_link = playlist_info['external_urls']['spotify']

    print(f"\nPlaylist updated successfully!")
    print(f"You can access your playlist '{PLAYLIST_NAME}' here: {playlist_link}")
    logging.info(f"Playlist link: {playlist_link}")

if __name__ == "__main__":
    main()

