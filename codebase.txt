Directory Structure:
====================

lastfm-spotify-liker/
    spotify_deduplicator.py
    requirements.txt
    database.py
    lastfm_spotify_liker.py
    utils.py
    unfound_tracks.txt
    spotify_operations.py


File Contents:
==============

File: spotify_deduplicator.py
=============================

import os
import sys
import logging
import time
import re
from datetime import datetime, timezone
import sqlite3
from dotenv import load_dotenv
import spotipy
from spotipy.oauth2 import SpotifyOAuth
from rapidfuzz import fuzz, process
from utils import normalize_string

load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class SpotifyDeduplicator:
    def __init__(self):
        self.sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope="user-library-read user-library-modify"))

    def fetch_all_liked_songs(self):
        offset = 0
        limit = 50
        all_tracks = []

        while True:
            results = self.sp.current_user_saved_tracks(limit=limit, offset=offset)
            tracks = results['items']
            if len(tracks) == 0:
                break
            all_tracks.extend(tracks)
            offset += limit

        logging.info(f"Fetched {len(all_tracks)} liked songs from Spotify.")
        return all_tracks

    def group_duplicates(self, tracks):
        track_map = {}
        for item in tracks:
            track = item['track']
            name = normalize_string(track['name'])
            artist = normalize_string(track['artists'][0]['name'])
            key = f"{artist} {name}"
            if key not in track_map:
                track_map[key] = []
            track_map[key].append(track)
        duplicates = {k: v for k, v in track_map.items() if len(v) > 1}
        logging.info(f"Found {len(duplicates)} groups of duplicate tracks.")
        return duplicates

    def select_preferred_track(self, tracks):
        # Apply your rules to select the preferred track
        # Rule 1: Prefer remastered versions
        remastered_tracks = [t for t in tracks if 'remaster' in t['name'].lower()]
        if remastered_tracks:
            tracks = remastered_tracks

        # Rule 2: Prefer tracks from deluxe/longer albums
        if len(tracks) > 1:
            album_lengths = {}
            for t in tracks:
                album_id = t['album']['id']
                if album_id not in album_lengths:
                    album = self.sp.album(album_id)
                    album_lengths[album_id] = len(album['tracks']['items'])
                t['album_length'] = album_lengths[album_id]
            max_length = max(t['album_length'] for t in tracks)
            tracks = [t for t in tracks if t['album_length'] == max_length]

        # Return the first track if multiple remain
        return tracks[0]

    def deduplicate(self):
        all_tracks = self.fetch_all_liked_songs()
        duplicates = self.group_duplicates(all_tracks)
        tracks_to_remove = []
        for key, tracks in duplicates.items():
            preferred_track = self.select_preferred_track(tracks)
            for t in tracks:
                if t['id'] != preferred_track['id']:
                    tracks_to_remove.append(t['id'])
                    logging.info(f"Removing duplicate track: {t['name']} by {t['artists'][0]['name']}")
        if tracks_to_remove:
            batch_size = 50
            for i in range(0, len(tracks_to_remove), batch_size):
                batch = tracks_to_remove[i:i+batch_size]
                retry_count = 0
                while retry_count < 3:  # Maximum 3 retries
                    try:
                        self.sp.current_user_saved_tracks_delete(tracks=batch)
                        break  # Success, exit the retry loop
                    except spotipy.exceptions.SpotifyException as e:
                        if e.http_status == 429:
                            retry_after = int(e.headers.get('Retry-After', 5))
                            logging.warning(f"Rate limited by Spotify. Retrying after {retry_after} seconds.")
                            time.sleep(retry_after)
                            retry_count += 1
                        else:
                            logging.error(f"Error removing tracks: {e}")
                            break  # Exit the retry loop for non-rate-limiting errors
                    except Exception as e:
                        logging.error(f"Unexpected error removing tracks: {e}")
                        break
                time.sleep(0.1)
            logging.info(f"Removed {len(tracks_to_remove)} duplicate tracks.")
        else:
            logging.info("No duplicates found to remove.")

def main():
    try:
        deduplicator = SpotifyDeduplicator()
        deduplicator.deduplicate()
    except KeyboardInterrupt:
        logging.info("Program interrupted by user. Exiting gracefully.")
        sys.exit(0)
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()


File: requirements.txt
======================

certifi==2024.8.30
charset-normalizer==3.4.0
idna==3.10
python-dotenv==1.0.1
RapidFuzz==3.10.0
redis==5.1.1
requests==2.32.3
spotipy==2.24.0
urllib3==2.2.3


File: database.py
=================

# database.py

import sqlite3
import logging
from datetime import datetime, timezone
from utils import normalize_string

class Database:
    def __init__(self, db_file='lastfm_history.db'):
        self.db_file = db_file
        self.create_table()

    def connect(self):
        return sqlite3.connect(self.db_file)

    def create_table(self):
        with self.connect() as conn:
            c = conn.cursor()
            # Create the tracks table if it doesn't exist
            c.execute('''
                CREATE TABLE IF NOT EXISTS tracks (
                    id INTEGER PRIMARY KEY,
                    artist TEXT,
                    name TEXT,
                    album TEXT,
                    listen_count INTEGER,
                    last_listened DATETIME,
                    mbid TEXT,
                    UNIQUE(artist, name)
                )
            ''')

    def add_or_update_track(self, track):
        artist = normalize_string(track['artist'])
        name = normalize_string(track['name'])
        album = normalize_string(track.get('album', ''))
        date = track['date'].astimezone(timezone.utc).isoformat()
        query = '''
        INSERT INTO tracks (artist, name, album, listen_count, last_listened, mbid)
        VALUES (?, ?, ?, 1, ?, ?)
        ON CONFLICT(artist, name) DO UPDATE SET
        listen_count = listen_count + 1,
        last_listened = ?,
        album = COALESCE(?, album),
        mbid = COALESCE(?, mbid)
        '''
        with self.connect() as conn:
            conn.execute(query, (
                artist,
                name,
                album,
                date,
                track.get('mbid', ''),
                date,
                album,
                track.get('mbid', '')
            ))

    def get_last_update_time(self):
        query = 'SELECT MAX(last_listened) FROM tracks'
        with self.connect() as conn:
            result = conn.execute(query).fetchone()
        if result and result[0]:
            # Ensure the returned datetime is timezone-aware and in UTC
            return datetime.fromisoformat(result[0]).replace(tzinfo=timezone.utc)
        return None

    def get_frequently_played_tracks(self, min_count=5):
        query = '''
        SELECT artist, name, listen_count
        FROM tracks
        WHERE listen_count >= ?
        ORDER BY listen_count DESC
        '''
        with self.connect() as conn:
            return conn.execute(query, (min_count,)).fetchall()


File: lastfm_spotify_liker.py
=============================

import os
import sys
import logging
import time
from datetime import datetime, timezone
import requests
from dotenv import load_dotenv
from database import Database
from spotify_operations import SpotifyOperations
from utils import normalize_string

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Load environment variables
load_dotenv()

# Last.fm API credentials
LASTFM_API_KEY = os.getenv('LASTFM_API_KEY')
LASTFM_USER = os.getenv('LASTFM_USER')
MIN_PLAY_COUNT = int(os.getenv('MIN_PLAY_COUNT', 5))

# Database file paths
LASTFM_DB_FILE = os.getenv('LASTFM_DB_FILE', 'lastfm_history.db')
SPOTIFY_DB_FILE = os.getenv('SPOTIFY_DB_FILE', 'spotify_liked_songs.db')

def get_new_lastfm_tracks(db, from_timestamp=None):
    url = 'http://ws.audioscrobbler.com/2.0/'
    params = {
        'method': 'user.getrecenttracks',
        'user': LASTFM_USER,
        'api_key': LASTFM_API_KEY,
        'format': 'json',
        'limit': 200,
        'from': from_timestamp
    }

    all_tracks = []
    page = 1
    total_pages = 1

    while True:
        params['page'] = page
        try:
            response = requests.get(url, params=params)
            response.raise_for_status()
            data = response.json()

            if 'error' in data:
                logging.error(f"Error fetching Last.fm tracks: {data['message']}")
                break

            tracks = data['recenttracks']['track']
            if not isinstance(tracks, list):
                tracks = [tracks]
            all_tracks.extend(tracks)

            total_pages = int(data['recenttracks']['@attr'].get('totalPages', 1))
            logging.info(f"Fetched page {page} of {total_pages}")

            if page >= total_pages:
                break
            page += 1

        except requests.RequestException as e:
            logging.error(f"Network error when fetching Last.fm tracks: {e}")
            break
        except Exception as e:
            logging.error(f"Unexpected error in get_new_lastfm_tracks: {e}")
            logging.exception(e)
            break

    for track in all_tracks:
        try:
            if 'date' in track:
                track['date'] = datetime.fromtimestamp(int(track['date']['uts'])).replace(tzinfo=timezone.utc)
            else:
                track['date'] = datetime.now(timezone.utc)  # For 'now playing' track

            # Safely extract artist name
            artist_name = track['artist']['#text'] if isinstance(track['artist'], dict) else track['artist']

            # Safely extract album name
            album_name = track['album']['#text'] if isinstance(track['album'], dict) else track['album']

            # Safely extract track name
            track_name = track['name']['#text'] if isinstance(track['name'], dict) else track['name']

            db.add_or_update_track({
                'artist': artist_name,
                'name': track_name,
                'album': album_name,
                'date': track['date'],
                'mbid': track.get('mbid', '')
            })
        except Exception as e:
            logging.error(f"Error processing track: {track}")
            logging.exception(e)
            continue

    return len(all_tracks)

def main():
    try:
        lastfm_db = Database(db_file=LASTFM_DB_FILE)
        spotify_ops = SpotifyOperations(db_file=SPOTIFY_DB_FILE)

        # Update Last.fm tracks
        last_update = lastfm_db.get_last_update_time()
        if last_update:
            logging.info(f"Fetching Last.fm tracks since {last_update}")
            new_tracks_count = get_new_lastfm_tracks(lastfm_db, int(last_update.timestamp()))
        else:
            logging.info("Fetching all Last.fm tracks (first run)")
            new_tracks_count = get_new_lastfm_tracks(lastfm_db)

        logging.info(f"Added or updated {new_tracks_count} tracks from Last.fm")

        # Update Spotify liked songs
        logging.info("Updating Spotify liked songs...")
        new_liked_songs_count = spotify_ops.update_liked_songs()
        logging.info(f"Spotify liked songs database updated.")

        # Get frequently played tracks from Last.fm
        frequently_played = lastfm_db.get_frequently_played_tracks(MIN_PLAY_COUNT)
        logging.info(f"Found {len(frequently_played)} tracks played more than {MIN_PLAY_COUNT} times on Last.fm")

        # Find tracks to be liked
        tracks_to_like = spotify_ops.find_tracks_to_like(frequently_played, min_play_count=MIN_PLAY_COUNT)
        logging.info(f"Found {len(tracks_to_like)} tracks to like on Spotify")

        # Like the tracks on Spotify
        if tracks_to_like:
            spotify_ops.like_tracks(tracks_to_like)
            logging.info(f"Finished liking tracks on Spotify")
        else:
            logging.info("No new tracks to like on Spotify")

        # Update Spotify liked songs again to ensure local database is current
        spotify_ops.update_liked_songs()

    except KeyboardInterrupt:
        logging.info("Program interrupted by user. Exiting gracefully.")
        sys.exit(0)
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()


File: utils.py
==============

# utils.py
import re

def normalize_string(s):
    s = s.lower().strip()
    # Remove content in parentheses or brackets
    s = re.sub(r'\s*[\(\[\{].*?[\)\]\}]', '', s)
    # Remove version-specific keywords and their accompanying years if any
    s = re.sub(r'\b(remastered|live|acoustic|mono|stereo|version|edit|feat\.?|featuring|from)\b(\s+\d{4})?', '', s)
    # Remove extra punctuation (but keep numbers)
    s = re.sub(r'[^a-zA-Z0-9\s]', '', s)
    # Remove extra whitespace
    s = re.sub(r'\s+', ' ', s)
    return s.strip()


File: unfound_tracks.txt
========================




File: spotify_operations.py
===========================

# spotify_operations.py

import os
import sys
import re
import logging
import time
from datetime import datetime, timezone
import sqlite3
from dotenv import load_dotenv
import spotipy
from spotipy.oauth2 import SpotifyOAuth
from rapidfuzz import fuzz, process
from utils import normalize_string

load_dotenv()

# Use environment variable for database file path
SPOTIFY_DB_FILE = os.getenv('SPOTIFY_DB_FILE', 'spotify_liked_songs.db')

class SpotifyOperations:
    """Handles operations related to Spotify, including searching and liking tracks."""

    def __init__(self, db_file=SPOTIFY_DB_FILE):
        """Initialize the Spotify operations and create necessary database tables."""
        self.sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope="user-library-read user-library-modify"))
        self.db_file = db_file
        self.create_table()

    def create_table(self):
        """Create necessary tables in the database if they don't exist."""
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        
        # Create the liked_songs table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS liked_songs
                     (id TEXT PRIMARY KEY, name TEXT, artist TEXT, album TEXT, album_id TEXT, added_at TEXT)''')
        
        # Create metadata table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS metadata
                     (key TEXT PRIMARY KEY, value TEXT)''')
        
        # Create search_cache table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS search_cache
                     (name TEXT, artist TEXT, track_id TEXT, PRIMARY KEY (name, artist))''')
        
        # Create unfound_tracks table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS unfound_tracks
                     (artist TEXT, name TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                      PRIMARY KEY (artist, name))''')
        
        conn.commit()
        conn.close()

    def fetch_all_liked_songs(self):
        offset = 0
        limit = 50
        all_tracks = []

        while True:
            results = self.sp.current_user_saved_tracks(limit=limit, offset=offset)
            tracks = results['items']
            if len(tracks) == 0:
                break
            all_tracks.extend(tracks)
            offset += limit

        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()

        for item in all_tracks:
            track = item['track']
            name = normalize_string(track['name'])
            artist = normalize_string(track['artists'][0]['name'])
            album = normalize_string(track['album']['name'])
            album_id = track['album']['id']
            c.execute("INSERT OR REPLACE INTO liked_songs VALUES (?, ?, ?, ?, ?, ?)",
                      (track['id'], name, artist, album, album_id, item['added_at']))

        conn.commit()
        conn.close()

        return len(all_tracks)

    def get_liked_songs_set(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT name, artist FROM liked_songs")
        liked_songs = c.fetchall()
        conn.close()
        # Use normalized strings for comparison
        return set((name, artist) for name, artist in liked_songs)

    def like_tracks(self, track_ids):
        batch_size = 50  # Spotify allows up to 50 tracks to be liked at once
        for i in range(0, len(track_ids), batch_size):
            batch = track_ids[i:i+batch_size]
            try:
                self.sp.current_user_saved_tracks_add(tracks=batch)
                logging.info(f"Liked {len(batch)} tracks")
                # After liking tracks, add them to the local database
                self._save_newly_liked_tracks(batch)
            except spotipy.exceptions.SpotifyException as e:
                logging.error(f"Error liking tracks: {e}")
                time.sleep(2)  # Wait before retrying
            time.sleep(0.1)  # Add a small delay to avoid rate limiting

    def _save_newly_liked_tracks(self, track_ids):
        # Fetch details of the newly liked tracks in batches
        batch_size = 50
        tracks = []
        for i in range(0, len(track_ids), batch_size):
            batch = track_ids[i:i+batch_size]
            response = self.sp.tracks(batch)
            for track in response['tracks']:
                tracks.append({
                    'added_at': datetime.utcnow().replace(tzinfo=timezone.utc).isoformat(),
                    'track': track
                })
            time.sleep(0.1)  # To respect rate limits

        self._save_tracks_to_db(tracks)

    def search_track(self, name, artist):
        """Search for a track on Spotify and return its ID if found."""
        # Check cache first
        cached_id = self.get_cached_track_id(name, artist)
        if cached_id is not None:
            return cached_id

        # Define query variations
        queries = [
            f"track:{name} artist:{artist}",
            f"track:{name}",
            f"{name} {artist}"
        ]

        for query in queries:
            track_id = self._search_and_match(query, name, artist)
            if track_id:
                self.cache_track_id(name, artist, track_id)
                return track_id

        # Cache negative result
        self.cache_track_id(name, artist, None)
        return None

    def _search_and_match(self, query, name, artist):
        """Perform a search query and match results against the given name and artist."""
        try:
            results = self.sp.search(q=query, type='track', limit=10)
            if results['tracks']['items']:
                best_match = None
                highest_score = 0
                for item in results['tracks']['items']:
                    spotify_name = normalize_string(item['name'])
                    spotify_artist = normalize_string(item['artists'][0]['name'])
                    name_score = fuzz.token_sort_ratio(name, spotify_name)
                    artist_score = fuzz.token_sort_ratio(artist, spotify_artist)
                    total_score = (name_score + artist_score) / 2
                    if total_score > highest_score:
                        highest_score = total_score
                        best_match = item['id']
                if highest_score > 80:  # Threshold can be adjusted
                    return best_match
            return None
        except spotipy.exceptions.SpotifyException as e:
            logging.error(f"Spotify API error: {e}")
            time.sleep(2)  # Wait before retrying
            return None
        finally:
            time.sleep(0.1)  # Small delay to respect rate limits

    def get_cached_track_id(self, name, artist):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT track_id FROM search_cache WHERE name = ? AND artist = ?", (name, artist))
        result = c.fetchone()
        conn.close()
        if result:
            return result[0] if result[0] != 'NOT_FOUND' else None
        return None

    def cache_track_id(self, name, artist, track_id):
        if track_id is None:
            track_id = 'NOT_FOUND'
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("INSERT OR REPLACE INTO search_cache (name, artist, track_id) VALUES (?, ?, ?)",
                  (name, artist, track_id))
        conn.commit()
        conn.close()

    def find_tracks_to_like(self, lastfm_tracks, min_play_count=5):
        """Find tracks from Last.fm that should be liked on Spotify."""
        spotify_liked = self.get_liked_songs_set()
        tracks_to_like = []

        for track in lastfm_tracks:
            if track[2] >= min_play_count:
                name = track[1]  # Already normalized when stored in the database
                artist = track[0]  # Already normalized when stored in the database

                if (name, artist) in spotify_liked:
                    continue  # Skip already liked tracks

                track_id = self.search_track(name, artist)
                if track_id:
                    tracks_to_like.append(track_id)
                    logging.info(f"Will like: {artist} - {name}")
                else:
                    logging.info(f"Couldn't find track on Spotify: {artist} - {name}")
                    self.add_unfound_track(artist, name)
            else:
                break

        return tracks_to_like

    def add_unfound_track(self, artist, name):
        """Add a track that couldn't be found on Spotify to the unfound_tracks table."""
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("INSERT OR IGNORE INTO unfound_tracks (artist, name) VALUES (?, ?)", (artist, name))
        conn.commit()
        conn.close()

    def get_last_update_time(self):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        c.execute("SELECT value FROM metadata WHERE key = 'last_update'")
        result = c.fetchone()
        conn.close()
        if result and result[0]:
            # Ensure the datetime is timezone-aware and in UTC
            return datetime.fromisoformat(result[0]).astimezone(timezone.utc)
        return None

    def set_last_update_time(self, update_time):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        # Ensure update_time is in ISO format with timezone info
        c.execute("INSERT OR REPLACE INTO metadata (key, value) VALUES (?, ?)",
                  ('last_update', update_time.astimezone(timezone.utc).isoformat()))
        conn.commit()
        conn.close()

    def fetch_new_liked_songs(self):
        last_update = self.get_last_update_time()
        offset = 0
        limit = 50
        new_tracks = []

        while True:
            results = self.sp.current_user_saved_tracks(limit=limit, offset=offset)
            if not results['items']:
                break
            for item in results['items']:
                added_at = datetime.strptime(item['added_at'], "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
                if last_update and added_at <= last_update:
                    # Since the list is in descending order, we can stop here
                    return new_tracks
                new_tracks.append(item)
            offset += limit
        return new_tracks

    def update_liked_songs(self, force_full_fetch=False):
        last_update = self.get_last_update_time()
        if last_update is None or force_full_fetch:
            logging.info("Fetching all liked songs from Spotify.")
            total_tracks = self.fetch_all_liked_songs()
            logging.info(f"Fetched {total_tracks} liked songs from Spotify.")
            self.set_last_update_time(datetime.now(timezone.utc))
            
            # Add logging to verify database update
            conn = sqlite3.connect(self.db_file)
            c = conn.cursor()
            c.execute("SELECT COUNT(*) FROM liked_songs")
            total_liked_songs = c.fetchone()[0]
            conn.close()
            logging.info(f"Total liked songs in local database: {total_liked_songs}")
            
            return total_tracks
        else:
            new_tracks = self.fetch_new_liked_songs()
            if not new_tracks:
                logging.info("No new liked songs to update.")
                return 0
            self._save_tracks_to_db(new_tracks)
            latest_added_at = max(
                datetime.strptime(item['added_at'], "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
                for item in new_tracks
            )
            self.set_last_update_time(latest_added_at)
            logging.info(f"Updated last update time to: {latest_added_at.isoformat()}")
            
            # Add logging to verify database update
            conn = sqlite3.connect(self.db_file)
            c = conn.cursor()
            c.execute("SELECT COUNT(*) FROM liked_songs")
            total_liked_songs = c.fetchone()[0]
            conn.close()
            logging.info(f"Total liked songs in local database after update: {total_liked_songs}")
            
            return len(new_tracks)

    def _save_tracks_to_db(self, tracks):
        conn = sqlite3.connect(self.db_file)
        c = conn.cursor()
        for item in tracks:
            track = item['track']
            name = normalize_string(track['name'])
            artist = normalize_string(track['artists'][0]['name'])
            album = normalize_string(track['album']['name'])
            album_id = track['album']['id']
            c.execute("INSERT OR REPLACE INTO liked_songs VALUES (?, ?, ?, ?, ?, ?)",
                      (track['id'], name, artist, album, album_id, item['added_at']))
        conn.commit()
        conn.close()

